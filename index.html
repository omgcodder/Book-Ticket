<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Premium Live Stream Player</title>
  <!-- Import Video.js CSS and JS -->
  <link href="https://cdnjs.cloudflare.com/ajax/libs/video.js/7.21.1/video-js.min.css" rel="stylesheet" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/video.js/7.21.1/video.min.js"></script>
  <!-- Import Video.js HTTP streaming plugin (VHS) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/videojs-http-streaming/2.16.2/videojs-http-streaming.min.js"></script>
  
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
      background-color: #121212;
      color: #ffffff;
    }
    
    main {
      max-width: 1200px;
      margin: 20px auto;
      padding: 0 20px;
    }
    
    .stream-container {
      width: 100%;
    }
    
    .player-section {
      width: 100%;
      position: relative;
    }
    
    .player-container {
      position: relative;
      width: 100%;
      background-color: #000;
      overflow: hidden;
      border-radius: 8px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
    }
    
    #videoWrapper {
      width: 100%;
      height: 100%;
    }
    
    .video-js {
      width: 100%;
      height: 100%;
    }
    
    /* Loading overlay */
    .loading-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.7);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 20;
      transition: opacity 0.3s;
    }
    
    .loading-overlay.hidden {
      opacity: 0;
      pointer-events: none;
    }
    
    .spinner {
      width: 50px;
      height: 50px;
      border: 5px solid rgba(255, 255, 255, 0.3);
      border-radius: 50%;
      border-top-color: #ffffff;
      animation: spinner 1s linear infinite;
    }
    
    @keyframes spinner {
      to {
        transform: rotate(360deg);
      }
    }
    
    /* Error overlay */
    .error-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.8);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 30;
      padding: 20px;
      text-align: center;
    }
    
    .error-overlay.hidden {
      display: none;
    }
    
    .error-icon {
      font-size: 48px;
      margin-bottom: 20px;
    }
    
    .error-message {
      font-size: 18px;
      margin-bottom: 20px;
      color: #fff;
      max-width: 80%;
    }
    
    .retry-button {
      padding: 10px 20px;
      background-color: #ff0000;
      color: white;
      border: none;
      border-radius: 4px;
      font-size: 16px;
      cursor: pointer;
      transition: background-color 0.2s;
    }
    
    .retry-button:hover {
      background-color: #cc0000;
    }
    
    /* Controls */
    .controls-container {
      position: absolute;
      bottom: 0;
      left: 0;
      width: 100%;
      background: linear-gradient(transparent, rgba(0, 0, 0, 0.8));
      padding: 10px;
      opacity: 0;
      transition: opacity 0.3s;
      z-index: 10;
    }
    
    .controls-container.active {
      opacity: 1;
    }
    
    .controls {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }
    
    .left-controls, .right-controls {
      display: flex;
      align-items: center;
    }
    
    .btn {
      background: transparent;
      border: none;
      color: white;
      width: 36px;
      height: 36px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      margin: 0 5px;
      border-radius: 50%;
      transition: background-color 0.2s;
    }
    
    .btn:hover {
      background-color: rgba(255, 255, 255, 0.2);
    }
    
    .btn svg {
      width: 24px;
      height: 24px;
    }
    
    /* Volume slider */
    .volume-container {
      display: flex;
      align-items: center;
    }
    
    .volume-slider {
      width: 0;
      height: 4px;
      background-color: rgba(255, 255, 255, 0.3);
      border-radius: 2px;
      position: relative;
      overflow: hidden;
      transition: width 0.3s;
      margin-left: 5px;
    }
    
    .volume-container:hover .volume-slider {
      width: 80px;
    }
    
    .volume-level {
      position: absolute;
      left: 0;
      top: 0;
      height: 100%;
      background-color: #ff0000;
      width: 100%;
    }
    
    /* Progress bar */
    .progress-container {
      width: 100%;
      height: 4px;
      background-color: rgba(255, 255, 255, 0.3);
      position: relative;
      cursor: pointer;
      border-radius: 2px;
      overflow: hidden;
    }
    
    .progress-bar {
      position: absolute;
      left: 0;
      top: 0;
      height: 100%;
      background-color: #ff0000;
      width: 0;
    }
    
    .progress-hover {
      position: absolute;
      left: 0;
      top: 0;
      height: 100%;
      background-color: rgba(255, 255, 255, 0.2);
      width: 0;
      transform: translateX(-100%);
      transition: transform 0.1s;
    }
    
    /* Live indicator */
    .live-indicator {
      display: flex;
      align-items: center;
      margin-left: 15px;
      padding: 3px 8px;
      background-color: rgba(0, 0, 0, 0.5);
      border-radius: 4px;
      cursor: pointer;
      opacity: 0.6;
      transition: opacity 0.2s, background-color 0.2s;
    }
    
    .live-indicator.active {
      background-color: rgba(255, 0, 0, 0.5);
      opacity: 1;
    }
    
    .live-indicator:hover {
      opacity: 1;
    }
    
    .live-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background-color: #ff0000;
      margin-right: 5px;
    }
    
    .live-indicator.active .live-dot {
      animation: pulse 1.5s infinite;
    }
    
    @keyframes pulse {
      0% {
        transform: scale(1);
        opacity: 1;
      }
      50% {
        transform: scale(1.3);
        opacity: 0.7;
      }
      100% {
        transform: scale(1);
        opacity: 1;
      }
    }
    
    /* Quality menu */
    .quality-menu {
      position: absolute;
      bottom: 70px;
      right: 10px;
      background-color: rgba(0, 0, 0, 0.9);
      border-radius: 4px;
      padding: 10px 0;
      z-index: 15;
      display: none;
      min-width: 120px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
    }
    
    .quality-menu.active {
      display: block;
    }
    
    .quality-option {
      padding: 8px 15px;
      cursor: pointer;
      transition: background-color 0.2s;
      color: #ccc;
    }
    
    .quality-option:hover {
      background-color: rgba(255, 255, 255, 0.1);
      color: #fff;
    }
    
    .quality-option.active {
      color: #ff0000;
    }
    
    /* Responsive and fullscreen styles */
    .player-container.fullscreen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 9999;
    }
    
    /* Custom url input */
    .url-input-container {
      display: flex;
      margin-bottom: 20px;
      gap: 10px;
    }
    
    .url-input {
      flex: 1;
      padding: 12px;
      border-radius: 4px;
      border: 1px solid #333;
      background-color: #1e1e1e;
      color: #fff;
      font-size: 16px;
    }
    
    .url-load-btn {
      padding: 0 20px;
      background-color: #ff0000;
      color: white;
      border: none;
      border-radius: 4px;
      font-size: 16px;
      cursor: pointer;
      transition: background-color 0.2s;
    }
    
    .url-load-btn:hover {
      background-color: #cc0000;
    }

    /* Stream selector */
    .stream-selector {
      margin-bottom: 20px;
    }
    
    .stream-options {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-bottom: 10px;
    }
    
    .stream-option {
      padding: 8px 16px;
      background-color: #333;
      color: white;
      border-radius: 4px;
      cursor: pointer;
      transition: background-color 0.2s;
    }
    
    .stream-option:hover {
      background-color: #444;
    }
    
    .stream-option.active {
      background-color: #ff0000;
    }

    /* Info badge */
    .info-badge {
      position: absolute;
      top: 10px;
      right: 10px;
      background-color: rgba(0, 0, 0, 0.6);
      padding: 5px 8px;
      border-radius: 4px;
      font-size: 12px;
      z-index: 5;
      opacity: 0;
      transition: opacity 0.3s;
    }
    
    .info-badge.active {
      opacity: 1;
    }

    .connection-info {
      display: flex;
      align-items: center;
      margin-top: 15px;
      padding: 15px;
      background-color: #1e1e1e;
      border-radius: 6px;
      font-size: 14px;
    }

    .connection-indicator {
      height: 12px;
      width: 12px;
      border-radius: 50%;
      margin-right: 10px;
    }

    .good {
      background-color: #4caf50;
    }

    .medium {
      background-color: #ff9800;
    }

    .poor {
      background-color: #f44336;
    }
  </style>
</head>
<body>
  <main>
    <div class="stream-container">
      <!-- Stream selector -->
      <div class="stream-selector">
        <h3>Select Stream</h3>
        <div class="stream-options" id="streamOptions">
          <!-- Stream options will be populated dynamically -->
        </div>
      </div>
      
      <!-- Custom URL input -->
<!--       <div class="url-input-container">
        <input type="text" id="customUrl" class="url-input" placeholder="Enter custom HLS stream URL (m3u8)">
        <button id="loadUrlBtn" class="url-load-btn">Load</button>
      </div> -->
      
      <div class="player-section">
        <div class="player-container" id="playerContainer">
          <!-- Video element -->
          <div id="videoWrapper">
            <video id="videoPlayer" class="video-js vjs-fluid" preload="auto"></video>
          </div>
          
          <!-- Info badge -->
          <div class="info-badge" id="infoBadge"></div>
          
          <!-- Loading overlay -->
          <div class="loading-overlay" id="loadingOverlay">
            <div class="spinner"></div>
          </div>
          
          <!-- Error overlay -->
          <div class="error-overlay hidden" id="errorOverlay">
            <div class="error-icon">⚠️</div>
            <div class="error-message" id="errorMessage">Unable to load stream</div>
            <button class="retry-button" id="retryButton">Retry</button>
          </div>
          
          <!-- Controls -->
          <div class="controls-container" id="controlsContainer">
            <div class="controls">
              <div class="left-controls">
                <button class="btn" id="playPauseBtn">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor"
                    stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <polygon points="5 3 19 12 5 21 5 3"></polygon>
                  </svg>
                </button>
                <div class="volume-container">
                  <button class="btn" id="volumeBtn">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor"
                      stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                      <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon>
                      <path d="M15.54 8.46a5 5 0 0 1 0 7.07"></path>
                      <path d="M19.07 4.93a10 10 0 0 1 0 14.14"></path>
                    </svg>
                  </button>
                  <div class="volume-slider" id="volumeSlider">
                    <div class="volume-level" id="volumeLevel"></div>
                  </div>
                </div>
                <div class="live-indicator" id="liveIndicator">
                  <div class="live-dot"></div>
                  <span>LIVE</span>
                </div>
              </div>
              <div class="right-controls">
                <button class="btn" id="qualityBtn">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor"
                    stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M12 2v4M12 18v4M4.93 4.93l2.83 2.83M16.24 16.24l2.83 2.83M2 12h4M18 12h4M4.93 19.07l2.83-2.83M16.24 7.76l2.83-2.83"></path>
                  </svg>
                </button>
                <button class="btn" id="fullscreenBtn">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor"
                    stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"></path>
                  </svg>
                </button>
              </div>
            </div>
            <div class="progress-container" id="progressContainer">
              <div class="progress-hover" id="progressHover"></div>
              <div class="progress-bar" id="progressBar"></div>
            </div>
          </div>
          
          <!-- Quality menu -->
          <div class="quality-menu" id="qualityMenu">
            <!-- Quality options will be populated dynamically -->
          </div>
        </div>
        
        <!-- Connection info -->
        <div class="connection-info">
          <div class="connection-indicator" id="connectionIndicator"></div>
          <div id="connectionText">Connection status will appear here</div>
        </div>
      </div>
    </div>
  </main>
  
  <script>
    document.addEventListener('DOMContentLoaded', function () {
      // DOM Elements
      const playerContainer = document.getElementById('playerContainer');
      const videoWrapper = document.getElementById('videoWrapper');
      const controlsContainer = document.getElementById('controlsContainer');
      const playPauseBtn = document.getElementById('playPauseBtn');
      const volumeBtn = document.getElementById('volumeBtn');
      const volumeSlider = document.getElementById('volumeSlider');
      const volumeLevel = document.getElementById('volumeLevel');
      const qualityBtn = document.getElementById('qualityBtn');
      const qualityMenu = document.getElementById('qualityMenu');
      const fullscreenBtn = document.getElementById('fullscreenBtn');
      const progressContainer = document.getElementById('progressContainer');
      const progressBar = document.getElementById('progressBar');
      const progressHover = document.getElementById('progressHover');
      const loadingOverlay = document.getElementById('loadingOverlay');
      const liveIndicator = document.getElementById('liveIndicator');
      const errorOverlay = document.getElementById('errorOverlay');
      const errorMessage = document.getElementById('errorMessage');
      const retryButton = document.getElementById('retryButton');
      const customUrl = document.getElementById('customUrl');
      const loadUrlBtn = document.getElementById('loadUrlBtn');
      const streamOptions = document.getElementById('streamOptions');
      const infoBadge = document.getElementById('infoBadge');
      const connectionIndicator = document.getElementById('connectionIndicator');
      const connectionText = document.getElementById('connectionText');
      
      // State variables
      let isPlaying = false;
      let isMuted = false;
      let isLive = true;
      let volume = 1;
      let currentQuality = 'auto';
      let player = null;
      let controlsTimeout;
      let infoBadgeTimeout;
      let bufferingCount = 0;
      let bufferingStartTime = 0;
      let lastBufferingTime = 0;
      let streamHealth = 'good'; // good, medium, poor
      
      // Stream list with working public examples
      const streams = [
        {
          name: 'Jio Hostar',
          url: 'https://ee4ee8c03a26.eu-central-1.playback.live-video.net/api/video/v1/eu-central-1.755921704393.channel.LOohfipmCQDP.m3u8',
          description: 'Good quality test stream'
        },
        {
          name: 'Test Stream',
          url: 'https://rbmn-live.akamaized.net/hls/live/590964/BoRB-AT/master.m3u8',
          description: 'Red Bull TV Live'
        }
      ];
      
      // Current stream index
      let currentStreamIndex = 0;
      let currentStreamUrl = streams[0].url;
      
      // Initialize stream options
      function initStreamOptions() {
        streamOptions.innerHTML = '';
        streams.forEach((stream, index) => {
          const option = document.createElement('div');
          option.className = `stream-option ${index === currentStreamIndex ? 'active' : ''}`;
          option.setAttribute('data-index', index);
          option.textContent = stream.name;
          option.addEventListener('click', () => {
            selectStream(index);
          });
          streamOptions.appendChild(option);
        });
      }
      
      // Select stream
      function selectStream(index) {
        if (index === currentStreamIndex) return;
        
        // Update active class
        document.querySelectorAll('.stream-option').forEach(option => {
          option.classList.remove('active');
        });
        const selectedOption = document.querySelector(`.stream-option[data-index="${index}"]`);
        if (selectedOption) selectedOption.classList.add('active');
        
        // Update current stream and load
        currentStreamIndex = index;
        currentStreamUrl = streams[index].url;
        initPlayer(currentStreamUrl);
        
        // Show stream info badge
        showInfoBadge(`Loading: ${streams[index].name}`);
      }
      
      // Show info badge
      function showInfoBadge(text, duration = 3000) {
        infoBadge.textContent = text;
        infoBadge.classList.add('active');
        
        clearTimeout(infoBadgeTimeout);
        infoBadgeTimeout = setTimeout(() => {
          infoBadge.classList.remove('active');
        }, duration);
      }
      
      // Update connection status
      function updateConnectionStatus() {
        let statusClass = '';
        let statusText = '';
        
        switch (streamHealth) {
          case 'good':
            statusClass = 'good';
            statusText = 'Connection: Good - Stream is playing smoothly';
            break;
          case 'medium':
            statusClass = 'medium';
            statusText = 'Connection: Fair - Occasional buffering detected';
            break;
          case 'poor':
            statusClass = 'poor';
            statusText = 'Connection: Poor - Frequent buffering, consider lowering quality';
            break;
        }
        
        connectionIndicator.className = 'connection-indicator';
        connectionIndicator.classList.add(statusClass);
        connectionText.textContent = statusText;
      }
      
      // Create or recreate the video element (to avoid invalid element errors)
      function resetVideoElement() {
        videoWrapper.innerHTML = '<video id="videoPlayer" class="video-js vjs-fluid" preload="auto"></video>';
      }
      
      // Initialize Video.js player with a given URL
      function initPlayer(url) {
        if (player) {
          player.dispose();
          player = null;
        }
        
        // Reset buffering metrics
        bufferingCount = 0;
        bufferingStartTime = 0;
        lastBufferingTime = 0;
        streamHealth = 'good';
        updateConnectionStatus();
        
        // Recreate the video element before initializing
        resetVideoElement();
        hideError();
        showLoading();
        
        const videoEl = document.getElementById('videoPlayer');
        const options = {
          controls: false,
          autoplay: true,
          preload: 'auto',
          fluid: true,
          liveui: true,
          responsive: true,
          html5: {
            vhs: {
              overrideNative: true,
              enableLowInitialPlaylist: true,
              limitRenditionByPlayerDimensions: true,
              useBandwidthFromLocalStorage: true,
              useNetworkInformationApi: true, // Use network info if available
              maxPlaylistRetries: 5 // More attempts for playlist loading
            },
            nativeAudioTracks: false,
            nativeVideoTracks: false
          },
          sources: [{
            src: url,
            type: 'application/x-mpegURL'
          }],
          liveTracker: {
            trackingThreshold: 5, // Seconds to consider stream 'live'
            liveTolerance: 15     // Additional seconds window for live-edge
          }
        };
        
        console.log('Initializing player with URL:', url);
        showInfoBadge(`Loading stream...`);
        
        // Initialize Video.js with the element reference
        player = videojs(videoEl, options, function() {
          console.log('Player initialized');
          
          // For debug purposes - we can inspect the player
          window.player = this;
          
          // Timeout to detect loading issues (30 seconds)
          const loadingTimeout = setTimeout(() => {
            if (!isPlaying) {
              handleStreamError('Stream is taking too long to load. Check your connection or try another stream.');
            }
          }, 30000);
          
          this.on('loadedmetadata', function() {
            console.log('Stream metadata loaded');
            clearTimeout(loadingTimeout);
            checkIfLive();
            
            // Get stream information
            try {
              if (this.tech() && this.tech().vhs) {
                const tech = this.tech();
                if (tech.vhs.playlists && tech.vhs.playlists.master) {
                  const master = tech.vhs.playlists.master;
                  console.log('Stream info:', {
                    playlists: master.playlists.length,
                    duration: master.duration,
                    minimumUpdatePeriod: master.minimumUpdatePeriod
                  });
                }
              }
            } catch (err) {
              console.warn('Could not get detailed stream info:', err);
            }
            
            showInfoBadge(`Stream loaded successfully`);
          });
          
          this.on('waiting', function() {
            console.log('Stream is buffering');
            showLoading();
            
            // Track buffering for health monitoring
            const now = Date.now();
            bufferingCount++;
            
            if (bufferingStartTime === 0) {
              bufferingStartTime = now;
            }
            
            lastBufferingTime = now;
            
            // Update health based on buffering frequency
            if (bufferingCount > 5) {
              const timeSpan = (now - bufferingStartTime) / 1000; // in seconds
              const bufferFrequency = bufferingCount / timeSpan * 60; // buffers per minute
              
              if (bufferFrequency > 5) {
                streamHealth = 'poor';
              } else if (bufferFrequency > 2) {
                streamHealth = 'medium';
              }
              
              updateConnectionStatus();
            }
          });
          
          this.on('playing', function() {
            console.log('Stream is playing');
            hideLoading();
            isPlaying = true;
            updatePlayPauseButton();
            clearTimeout(loadingTimeout);
          });
          
          this.on('pause', function() {
            isPlaying = false;
            updatePlayPauseButton();
          });
          
          this.on('timeupdate', function() {
            updateProgressBar();
            checkIfLive();
          });
          
          this.on('volumechange', function() {
            isMuted = this.muted();
            volume = this.volume();
            updateVolumeButton();
            updateVolumeSlider();
          });
          
          this.on('error', function(e) {
            const error = this.error();
            console.error('Video.js error:', error);
            
            let errorMsg = 'Stream error occurred.';
            if (error) {
              // Provide more specific error messages based on error code
              switch (error.code) {
                case 1: // MEDIA_ERR_ABORTED
                  errorMsg = 'Stream playback aborted.';
                  break;
                case 2: // MEDIA_ERR_NETWORK
                  errorMsg = 'Network error. Please check your connection and try again.';
                  break;
                case 3: // MEDIA_ERR_DECODE
                  errorMsg = 'Stream decoding error. The video might be corrupted.';
                  break;
                case 4: // MEDIA_ERR_SRC_NOT_SUPPORTED
                  errorMsg = 'This stream format is not supported by your browser.';
                  break;
                case 5: // MEDIA_ERR_ENCRYPTED
                  errorMsg = 'This stream is encrypted and cannot be played.';
                  break;
                default:
                  errorMsg = `Stream error (${error.code}): ${error.message}`;
              }
            }
            
            handleStreamError(errorMsg);
          });
          
          // Monitor HLS specific errors and quality changes
          if (this.tech() && this.tech().vhs) {
            const tech = this.tech();
            
            // Listen for HLS errors
            if (tech.vhs.stats) {
              tech.on('progress', function() {
                try {
                  const stats = tech.vhs.stats;
                  if (stats.mediaRequests && stats.mediaBytesTransferred) {
                    // For debugging - can track bandwidth usage
                    console.debug('HLS stats:', {
                      mediaRequests: stats.mediaRequests,
                      bandwidth: stats.bandwidth
                    });
                  }
                } catch (err) {
                  console.warn('Error accessing HLS stats:', err);
                }
              });
// Listen for quality level changes
              if (tech.vhs.representations) {
                tech.on('mediachange', function() {
                  try {
                    const activeRep = tech.vhs.representations().find(rep => rep.enabled());
                    if (activeRep) {
                      const height = activeRep.height || Math.round(activeRep.bandwidth / 10000);
                      showInfoBadge(`Quality changed to ${height}p`, 2000);
                    }
                  } catch (err) {
                    console.warn('Error tracking quality change:', err);
                  }
                });
              }
            }
          }
          
          // Set initial volume
          this.volume(volume);
          updateVolumeSlider();
        });
        
        // Populate quality menu after a short delay
        player.ready(function() {
          setTimeout(() => {
            populateQualityMenu();
          }, 3000);
        });
      }
      
      function handleStreamError(msg) {
        console.error(msg);
        showError(msg);
      }
      
      function showError(msg) {
        errorMessage.textContent = msg;
        errorOverlay.classList.remove('hidden');
        hideLoading();
      }
      
      function hideError() {
        errorOverlay.classList.add('hidden');
      }
      
      function populateQualityMenu() {
        qualityMenu.innerHTML = '';
        
        // Auto quality option
        const autoOption = document.createElement('div');
        autoOption.className = 'quality-option' + (currentQuality === 'auto' ? ' active' : '');
        autoOption.setAttribute('data-quality', 'auto');
        autoOption.setAttribute('data-index', '-1');
        autoOption.textContent = 'Auto';
        qualityMenu.appendChild(autoOption);
        
        try {
          if (player && player.tech && player.tech() && player.tech().vhs) {
            const tech = player.tech();
            if (tech.vhs && tech.vhs.representations) {
              const representations = tech.vhs.representations();
              if (representations && representations.length > 0) {
                console.log('Found', representations.length, 'quality levels');
                
                // Sort representations by bandwidth (highest first)
                const sortedReps = [...representations].sort((a, b) => {
                  return b.bandwidth - a.bandwidth;
                });
                
                sortedReps.forEach((rep, index) => {
                  const height = rep.height || Math.round(rep.bandwidth / 10000);
                  const bandwidth = Math.round(rep.bandwidth / 1000); // kbps
                  
                  const option = document.createElement('div');
                  option.className = 'quality-option';
                  option.setAttribute('data-quality', `${height}p`);
                  option.setAttribute('data-index', index.toString());
                  option.textContent = `${height}p (${bandwidth} kbps)`;
                  qualityMenu.appendChild(option);
                });
              } else {
                console.log('No quality representations found, using fallback options');
                addFallbackQualityOptions();
              }
            } else {
              console.log('VHS representations not available, using fallback options');
              addFallbackQualityOptions();
            }
          } else {
            console.log('Tech or VHS not available, using fallback options');
            addFallbackQualityOptions();
          }
        } catch (err) {
          console.error('Error populating quality menu:', err);
          addFallbackQualityOptions();
        }
        
        // Add event listeners for quality options
        document.querySelectorAll('.quality-option').forEach(option => {
          option.addEventListener('click', function() {
            const index = parseInt(this.getAttribute('data-index'));
            const quality = this.getAttribute('data-quality');
            changeQuality(index, quality);
            qualityMenu.classList.remove('active');
          });
        });
      }
      
      function addFallbackQualityOptions() {
        const qualities = [
          { height: 1080, index: 0, bandwidth: 5000 },
          { height: 720, index: 1, bandwidth: 2500 },
          { height: 480, index: 2, bandwidth: 1000 },
          { height: 360, index: 3, bandwidth: 600 }
        ];
        qualities.forEach(q => {
          const option = document.createElement('div');
          option.className = 'quality-option';
          option.setAttribute('data-quality', `${q.height}p`);
          option.setAttribute('data-index', q.index.toString());
          option.textContent = `${q.height}p (${q.bandwidth} kbps)`;
          qualityMenu.appendChild(option);
        });
      }
      
      function changeQuality(index, quality) {
        if (!player || !player.tech || !player.tech()) return;
        try {
          const tech = player.tech();
          currentQuality = quality;
          
          if (index === -1) {
            // Auto quality
            if (tech.vhs && tech.vhs.representations) {
              tech.vhs.representations().forEach(rep => rep.enabled(true));
              console.log('Set to auto quality');
              showInfoBadge('Quality: Auto (adaptive)', 2000);
            }
          } else if (tech.vhs && tech.vhs.representations) {
            const representations = tech.vhs.representations();
            // Sort by bandwidth (highest first)
            const sortedReps = [...representations].sort((a, b) => {
              return b.bandwidth - a.bandwidth;
            });
            
            // Enable only the selected quality
            sortedReps.forEach((rep, idx) => {
              rep.enabled(idx === index);
            });
            
            console.log('Set quality to:', quality);
            showInfoBadge(`Quality: ${quality}`, 2000);
          }
          
          // Update UI
          document.querySelectorAll('.quality-option').forEach(opt => {
            opt.classList.remove('active');
          });
          const selected = document.querySelector(`.quality-option[data-index="${index}"]`);
          if (selected) selected.classList.add('active');
        } catch (err) {
          console.error('Error changing quality:', err);
        }
      }
      
      function togglePlay() {
        if (player) {
          if (player.paused()) {
            player.play().catch(err => {
              console.error('Error playing video:', err);
              showError('Failed to play video. Please try again.');
            });
          } else {
            player.pause();
          }
        }
      }
      
      function updatePlayPauseButton() {
        if (isPlaying) {
          playPauseBtn.innerHTML = `
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor"
              stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <rect x="6" y="4" width="4" height="16"></rect>
              <rect x="14" y="4" width="4" height="16"></rect>
            </svg>`;
        } else {
          playPauseBtn.innerHTML = `
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor"
              stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <polygon points="5 3 19 12 5 21 5 3"></polygon>
            </svg>`;
        }
      }
      
      function toggleMute() {
        if (player) {
          player.muted(!player.muted());
        }
      }
      
      function updateVolumeButton() {
        if (isMuted || (player && player.volume() === 0)) {
          volumeBtn.innerHTML = `
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor"
              stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon>
              <line x1="23" y1="9" x2="17" y2="15"></line>
              <line x1="17" y1="9" x2="23" y2="15"></line>
            </svg>`;
        } else if (player && player.volume() < 0.5) {
          volumeBtn.innerHTML = `
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor"
              stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon>
              <path d="M15.54 8.46a5 5 0 0 1 0 7.07"></path>
            </svg>`;
        } else {
          volumeBtn.innerHTML = `
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor"
              stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon>
              <path d="M15.54 8.46a5 5 0 0 1 0 7.07"></path>
              <path d="M19.07 4.93a10 10 0 0 1 0 14.14"></path>
            </svg>`;
        }
      }
      
      function updateVolumeSlider() {
        if (player) {
          volumeLevel.style.width = (player.volume() * 100) + '%';
        }
      }
      
      function toggleFullscreen() {
        if (!document.fullscreenElement) {
          if (playerContainer.requestFullscreen) {
            playerContainer.requestFullscreen();
          } else if (playerContainer.webkitRequestFullscreen) {
            playerContainer.webkitRequestFullscreen();
          } else if (playerContainer.msRequestFullscreen) {
            playerContainer.msRequestFullscreen();
          }
          playerContainer.classList.add('fullscreen');
        } else {
          if (document.exitFullscreen) {
            document.exitFullscreen();
          } else if (document.webkitExitFullscreen) {
            document.webkitExitFullscreen();
          } else if (document.msExitFullscreen) {
            document.msExitFullscreen();
          }
          playerContainer.classList.remove('fullscreen');
        }
      }
      
      function updateProgressBar() {
        if (!player || isLive || isNaN(player.duration())) return;
        const percentage = (player.currentTime() / player.duration()) * 100;
        progressBar.style.width = percentage + '%';
      }
      
      function seekVideo(e) {
        if (isLive || !player || isNaN(player.duration())) return;
        const rect = progressContainer.getBoundingClientRect();
        const position = (e.clientX - rect.left) / rect.width;
        const seekTime = player.duration() * position;
        player.currentTime(seekTime);
        progressBar.style.width = (position * 100) + '%';
        isLive = false;
        updateLiveIndicator();
      }
      
      function showProgressHover(e) {
        if (isLive || !player || isNaN(player.duration())) return;
        const rect = progressContainer.getBoundingClientRect();
        const position = (e.clientX - rect.left) / rect.width;
        progressHover.style.width = (position * 100) + '%';
        progressHover.style.transform = 'translateX(0)';
      }
      
      function hideProgressHover() {
        progressHover.style.transform = 'translateX(-100%)';
      }
      
      function checkIfLive() {
        if (!player || isNaN(player.duration())) return;
        
        // Check if player has liveTracker to determine live status
        if (player.liveTracker && player.liveTracker.isLive()) {
          isLive = player.liveTracker.atLiveEdge();
        } else {
          // Fallback method for older versions
          const liveThreshold = 10;
          const currentTime = player.currentTime();
          const duration = player.duration();
          isLive = (duration - currentTime) < liveThreshold;
        }
        
        updateLiveIndicator();
      }
      
      function updateLiveIndicator() {
        if (isLive) {
          liveIndicator.classList.add('active');
        } else {
          liveIndicator.classList.remove('active');
        }
      }
      
      function goToLive() {
        if (!isLive && player && !isNaN(player.duration())) {
          // If player has liveTracker use it to seek to live
          if (player.liveTracker && player.liveTracker.isLive()) {
            player.liveTracker.seekToLiveEdge();
          } else {
            // Fallback
            player.currentTime(player.duration());
          }
          
          isLive = true;
          updateLiveIndicator();
          showInfoBadge('Jumped to live edge', 1500);
        }
      }
      
      function showLoading() {
        loadingOverlay.classList.remove('hidden');
      }
      
      function hideLoading() {
        loadingOverlay.classList.add('hidden');
      }
      
      function resetControlsTimer() {
        if (controlsTimeout) clearTimeout(controlsTimeout);
        controlsContainer.classList.add('active');
        controlsTimeout = setTimeout(() => {
          if (isPlaying && !qualityMenu.classList.contains('active')) {
            controlsContainer.classList.remove('active');
          }
        }, 3000);
      }
      
      // Load custom URL
      function loadCustomUrl() {
        const url = customUrl.value.trim();
        if (url) {
          if (url.toLowerCase().endsWith('.m3u8')) {
            currentStreamUrl = url;
            initPlayer(url);
            showInfoBadge('Loading custom stream...', 2000);
            
            // Deselect stream options
            document.querySelectorAll('.stream-option').forEach(option => {
              option.classList.remove('active');
            });
          } else {
            showError('Please enter a valid HLS stream URL (ending with .m3u8)');
          }
        } else {
          showError('Please enter a valid stream URL');
        }
      }
      
      // Event Listeners
      playPauseBtn.addEventListener('click', togglePlay);
      volumeBtn.addEventListener('click', toggleMute);
      fullscreenBtn.addEventListener('click', toggleFullscreen);
      qualityBtn.addEventListener('click', () => {
        qualityMenu.classList.toggle('active');
      });
      liveIndicator.addEventListener('click', goToLive);
      retryButton.addEventListener('click', () => {
        hideError();
        initPlayer(currentStreamUrl);
      });
      loadUrlBtn.addEventListener('click', loadCustomUrl);
      customUrl.addEventListener('keyup', (e) => {
        if (e.key === 'Enter') {
          loadCustomUrl();
        }
      });
      
      progressContainer.addEventListener('click', seekVideo);
      progressContainer.addEventListener('mousemove', showProgressHover);
      progressContainer.addEventListener('mouseleave', hideProgressHover);
      volumeSlider.addEventListener('click', (e) => {
        const rect = volumeSlider.getBoundingClientRect();
        const position = (e.clientX - rect.left) / rect.width;
        if (player) {
          player.volume(Math.max(0, Math.min(1, position)));
          player.muted(false);
        }
      });
      
      // Hide UI on inactivity
      playerContainer.addEventListener('mousemove', resetControlsTimer);
      
      // Toggle play/pause on click
      playerContainer.addEventListener('click', (e) => {
        // Only toggle if clicking directly on the player or video
        if (e.target === playerContainer || e.target.id === 'videoPlayer' || e.target.classList.contains('vjs-tech')) {
          togglePlay();
        }
      });
      
      // Keyboard shortcuts
      document.addEventListener('keydown', (e) => {
        if (!player) return;
        
        switch (e.key) {
          case ' ':
          case 'k':
            togglePlay();
            e.preventDefault();
            break;
          case 'm':
            toggleMute();
            break;
          case 'f':
            toggleFullscreen();
            break;
          case 'l':
            // Go to live edge with 'l' key
            goToLive();
            break;
          case 'q':
            // Toggle quality menu with 'q' key
            qualityMenu.classList.toggle('active');
            break;
          case 'ArrowRight':
            if (!isLive && !isNaN(player.duration())) {
              player.currentTime(Math.min(player.currentTime() + 10, player.duration()));
              isLive = (player.duration() - player.currentTime()) < 10;
              updateLiveIndicator();
            }
            break;
          case 'ArrowLeft':
            if (!isNaN(player.duration())) {
              player.currentTime(Math.max(player.currentTime() - 10, 0));
              isLive = false;
              updateLiveIndicator();
            }
            break;
          case 'ArrowUp':
            if (player.volume() < 1) {
              player.volume(Math.min(player.volume() + 0.1, 1));
              player.muted(false);
            }
            e.preventDefault();
            break;
          case 'ArrowDown':
            if (player.volume() > 0) {
              player.volume(Math.max(player.volume() - 0.1, 0));
            }
            e.preventDefault();
            break;
        }
      });
      
      // Handle fullscreen change
      document.addEventListener('fullscreenchange', function() {
        if (!document.fullscreenElement) {
          playerContainer.classList.remove('fullscreen');
        }
      });
      
      // Clean up
      window.addEventListener('beforeunload', () => {
        if (player) player.dispose();
      });
      
      // Initialize
      initStreamOptions();
      initPlayer(streams[0].url);
      resetControlsTimer();
    });
  </script>
</body>
</html>
